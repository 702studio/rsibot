<!-- Improved copy of 508 with fixes and enhancements -->
<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nihai Backtest Platformu (Definitive Edition)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Funnel+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {--bg-color:#101214;--surface-color:#1b1d1f;--primary-color:#ffcc33;--primary-hover:#e0a021;--text-color:#e0e0e0;--label-color:#bbb;--border-color:#333;--profit-color:#00ff9d;--loss-color:#ff4d6a;}
        body { font-family:'Funnel Sans',sans-serif;background-color:var(--bg-color);color:var(--text-color);padding:15px;line-height:1.7;font-size:15px;margin:0; }
        .container { max-width:900px;margin:0 auto; }
        .header { display:flex;justify-content:space-between;align-items:center;margin-bottom:20px; }
        #reportBtn { background-color:#28a745;color:#fff;padding:8px 14px;border-radius:4px;font-weight:600;text-decoration:none; }
        h1, h2 { color:var(--primary-color);border-bottom:1px solid var(--border-color);padding-bottom:10px;font-size:1.5em; }
        h2 { font-size:1.1em;color:var(--label-color);margin-top:25px;margin-bottom:15px;border:none;padding:0;}
        .section { background-color:var(--surface-color);padding:20px;border-radius:8px;border:1px solid var(--border-color); margin-bottom:25px; }
        .config-grid { display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:20px; }
        .config-item { display:flex;flex-direction:column; }
        .config-item label { display:flex;align-items:center;gap:6px; }
        .config-item input[type=checkbox] { width:auto; }
        .full-width { grid-column:1 / -1; }
        label { color:var(--label-color);margin-bottom:8px;font-size:13px; }
        select, input { font-family:'Funnel Sans',sans-serif;background-color:#333;color:var(--text-color);border:1px solid #555;padding:10px;border-radius:4px;font-size:15px;width:100%;box-sizing:border-box; }
        .chip-container { display:flex;flex-wrap:wrap;gap:6px; }
        .period-chip { padding:6px 12px;border:1px solid #555;border-radius:12px;cursor:pointer;font-size:13px;background-color:#333;color:var(--text-color);user-select:none; }
        .period-chip.selected { background-color:var(--primary-color);color:#121212; }
        .strategy-grid { display:flex;flex-wrap:nowrap;overflow-x:auto;gap:10px;padding-bottom:10px; }
        .strategy-card { flex:1 1 180px;background-color:#333;padding:12px;border:1px solid #555;border-radius:8px;cursor:pointer; }
        .strategy-card.selected { border-color:var(--primary-color);background-color:#444; }
        .lang-btn { margin-left:5px;padding:6px 10px;border:none;background:#555;color:#fff;border-radius:4px;cursor:pointer; }
        .toggle { position:relative;display:inline-block;width:40px;height:20px; }
        .toggle input { opacity:0;width:0;height:0; }
        .toggle .slider { position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#555;transition:.4s;border-radius:20px; }
        .toggle .slider:before { position:absolute;content:"";height:14px;width:14px;left:3px;bottom:3px;background-color:white;transition:.4s;border-radius:50%; }
        .toggle input:checked + .slider { background-color:var(--primary-color); }
        .toggle input:checked + .slider:before { transform:translateX(20px); }
        .chart-container { height:300px;margin-bottom:20px; }
        optgroup { font-style:italic;background-color:#252525;color:var(--label-color); }
        #leverage-settings, #smart-leverage-settings { display:none; }
        .action-buttons { display:flex;gap:15px; }
        button { flex-grow:1;padding:12px 20px;cursor:pointer;border:none;font-weight:700;font-size:16px;border-radius:4px;transition:background-color .3s; }
        button#runBtn { background-color:var(--primary-color);color:#121212; }
        button#downloadBtn { background-color:#28a745;color:#fff; }
        button:disabled { background-color:#555;cursor:not-allowed;color:#999; }
        #progress-container { display:none;margin-top:25px;background-color:var(--surface-color);padding:15px;border-radius:8px; }
        #progress-bar { width:0%;height:10px;background-color:var(--primary-color);transition:width .3s ease-in-out;border-radius:4px;}
        #progress-log { font-size:13px;color:var(--label-color);margin-top:10px;white-space:pre; }
        #results { display:none;margin-top:25px; }
        .report-section { background-color:var(--surface-color); padding:20px; border-radius:8px; border:1px solid var(--border-color); margin-bottom:20px; }
        .report-section h3 { margin-top:0; color:var(--primary-color); border-bottom:1px solid var(--border-color); padding-bottom:10px; }
        .report-dl { display:grid;grid-template-columns:max-content auto;gap:10px 20px; } .report-dl dt { grid-column-start:1;font-weight:700;color:var(--label-color); } .report-dl dd { grid-column-start:2; }
        .report-dl strong { font-size:1.2em; } .log-container { font-size:12px; max-height:300px; overflow-y:auto; } .log-container p { margin:4px 0; }
        .profit { color:var(--profit-color); } .loss { color:var(--loss-color); }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 data-i18n="app_title">Nihai Backtest Platformu</h1>
            <div>
                <a id="reportBtn" data-i18n="report_download" href="gelistirme_raporu.html" download>Geliştirme Raporu</a>
                <button class="lang-btn" onclick="setLanguage('tr')">TR</button>
                <button class="lang-btn" onclick="setLanguage('en')">EN</button>
            </div>
        </div>
        <div class="section">
            <h2 data-i18n="general_settings">Genel Ayarlar</h2>
            <div class="config-grid">
                <div class="config-item full-width"><label for="strategy">Strateji Seçin</label><select id="strategy" style="display:none" onchange="toggleSettings()"><optgroup label="--- Akıllı Kaldıraç ---"><option value="rsi_smart_leverage" selected>Akıllı Kaldıraç RSI</option></optgroup><optgroup label="--- Standart Kaldıraç ---"><option value="rsi_leveraged">RSI Kaldıraçlı (Standart)</option></optgroup><optgroup label="--- Spot Stratejileri ---"><option value="rsi_plus_spot">RSI+ (Trend Filtreli)</option><option value="rsi_reversal">RSI Geri Dönüşü (Standart)</option><option value="ma_crossover">MA Kesişimi (Trend Takip)</option><option value="bollinger_bands">Bollinger Bandı (Volatilite)</option></optgroup></select><div id="strategy-cards" class="strategy-grid"></div></div>
                <div class="config-item"><label for="initialBalance">Başlangıç Bakiyesi (USD)</label><input type="number" id="initialBalance" value="10000"></div>
                <div class="config-item"><label for="interval">Zaman Aralığı</label><select id="interval"><option value="1m">1 Dakika</option><option value="15m">15 Dakika</option><option value="30m">30 Dakika</option><option value="1h">1 Saat</option><option value="4h" selected>4 Saat</option><option value="1d">1 Gün</option></select></div>
                <div class="config-item"><label for="direction">İşlem Yönü</label><select id="direction"><option value="long" selected>Sadece Long</option><option value="short">Sadece Short</option><option value="both">Her İkisi</option></select></div>
                <div class="config-item full-width">
                    <label>Test Periyodu (seçmek için dokun veya tıkla, çift tık tek seçim)</label>
                    <div id="timeframe-chips" class="chip-container"></div>
                </div>
                <div id="strategy-settings" class="config-grid"></div>
            </div>
        </div>
        <div class="section">
            <h2 data-i18n="cost_settings">Maliyet & Kaldıraç Ayarları</h2>
            <div class="config-grid">
                <div class="config-item"><label for="commission">İşlem Komisyonu (%)</label><input type="number" id="commission" value="0.04" step="0.01"></div>
                <div class="config-item"><label for="fundingRate">Saatlik Fonlama (%)</label><input type="number" id="fundingRate" value="0.00125" step="0.0001"></div>
                <div class="config-item full-width"><label for="compoundProfits">Kârı İşleme Ekle</label><label class="toggle"><input type="checkbox" id="compoundProfits" checked><span class="slider"></span></label></div>
                    <div class="config-item"><label for="stopLossPercent">Zarar Durdur (%)</label><input type="number" id="stopLossPercent" value="0"></div>
                    <div class="config-item"><label for="takeProfitPercent">Kâr Al (%)</label><input type="number" id="takeProfitPercent" value="0"></div>
                    <div class="config-item"><label for="riskProfile">Risk Yönetim Profili</label><select id="riskProfile" onchange="applyRiskProfile()"><option value="manual" selected>Manuel Ayar</option><option value="balanced">Dengeli Büyüme (1:2 R:R)</option><option value="aggressive">Agresif Fırsatçı (1:3 R:R)</option></select></div>
                <div id="leverage-settings" class="full-width config-grid" style="padding:0; border:none; background:none;">
                    <div class="config-item"><label for="marginType">Margin Tipi</label>
                        <select id="marginType">
                            <option value="isolated" selected>İzole Margin (Güvenli)</option>
                            <option value="cross">Çapraz Margin (Tüm Kasa)</option>
                        </select>
                    </div>
                    <div class="config-item"><label for="leverage">Kaldıraç (x)</label><input type="number" id="leverage" value="5"></div>
                    <div class="config-item"><label for="marginPercent">Margin Oranı (%)</label><input type="number" id="marginPercent" value="10"></div>
                </div>
                 <div id="smart-leverage-settings" class="full-width config-grid" style="padding:0; border:none; background:none;">
                    <div class="config-item"><label for="positionSize">İşlem Büyüklüğü (USD)</label><input type="number" id="positionSize" value="25000"></div>
                </div>
            </div>
        </div>
        <div class="action-buttons"><button id="runBtn" onclick="runBacktest()" data-i18n="run_backtest">Backtest'i Başlat</button><button id="downloadBtn" onclick="generateAndDownloadHtmlReport()" style="display:none;" data-i18n="download_report">Raporu İndir</button></div>
        <div id="progress-container"></div>
        <div id="results"><div id="equityChart" class="chart-container"></div><div id="priceChart" class="chart-container"></div></div>
    </div>

<script>
(function() {
    let allResultsHtml = "";
    let allResults = [];
    const defaultSettings = {
        rsi_smart_leverage: { leverage:5, marginPercent:10, hourlyFundingRate:0.00125, marginType:"isolated", positionSize:25000 },
        rsi_leveraged: { leverage:5, marginPercent:10, hourlyFundingRate:0.00125, marginType:"isolated" },
        rsi_plus_spot: { rsiPeriod:14, rsiBuyLevel:30, emaPeriod:200 },
        rsi_reversal: { rsiPeriod:14, rsiBuyLevel:30 },
        ma_crossover: { shortPeriod:20, longPeriod:50 },
        bollinger_bands: { period:20, stdDev:2 }
    };

    const translations = {
        tr: {
            app_title: "Nihai Backtest Platformu",
            report_download: "Geliştirme Raporu",
            general_settings: "Genel Ayarlar",
            cost_settings: "Maliyet & Kaldıraç Ayarları",
            run_backtest: "Backtest'i Başlat",
            download_report: "Raporu İndir"
        },
        en: {
            app_title: "Ultimate Backtest Platform",
            report_download: "Download Report",
            general_settings: "General Settings",
            cost_settings: "Cost & Leverage Settings",
            run_backtest: "Run Backtest",
            download_report: "Download Report"
        }
    };

    function setLanguage(lang){
        localStorage.setItem('lang', lang);
        document.querySelectorAll('[data-i18n]').forEach(el=>{
            const key = el.dataset.i18n;
            if(translations[lang] && translations[lang][key]) el.textContent = translations[lang][key];
        });
    }

    function initPeriodChips() {
        const periods = [
            {d:1,l:'1 Gün'},{d:2,l:'2 Gün'},{d:3,l:'3 Gün'},{d:4,l:'4 Gün'},{d:5,l:'5 Gün'},{d:6,l:'6 Gün'},
            {d:7,l:'1 Hafta'},{d:14,l:'2 Hafta'},{d:21,l:'3 Hafta'},
            {d:30,l:'1 Ay'},{d:60,l:'2 Ay'},{d:90,l:'3 Ay'},{d:120,l:'4 Ay'},{d:150,l:'5 Ay'},{d:180,l:'6 Ay'},{d:210,l:'7 Ay'},{d:240,l:'8 Ay'},{d:270,l:'9 Ay'},{d:300,l:'10 Ay'},{d:330,l:'11 Ay'},{d:365,l:'1 Yıl'},
            {d:730,l:'2 Yıl'},{d:1095,l:'3 Yıl'},{d:1825,l:'5 Yıl'},{d:3650,l:'10 Yıl'},{d:7300,l:'20 Yıl'}
        ];
        const container = document.getElementById('timeframe-chips');
        periods.forEach(p=>{
            const chip = document.createElement('div');
            chip.className='period-chip';
            chip.dataset.days=p.d;
            chip.textContent=p.l;
            if(p.d===30) chip.classList.add('selected');
            chip.addEventListener('click',e=>{
                if(e.detail===2){
                    document.querySelectorAll('.period-chip').forEach(c=>c.classList.remove('selected'));
                    chip.classList.add('selected');
                } else if(e.ctrlKey||e.metaKey){
                    chip.classList.toggle('selected');
                } else {
                    chip.classList.toggle('selected');
                }
            });
            container.appendChild(chip);
        });
    }
    function initStrategyCards() {
        const select = document.getElementById("strategy");
        const container = document.getElementById("strategy-cards");
        Array.from(select.options).forEach(opt => {
            const card = document.createElement("div");
            card.className = "strategy-card";
            card.dataset.strategy = opt.value;
            card.textContent = opt.textContent;
            card.addEventListener("click", () => {
                document.querySelectorAll(".strategy-card").forEach(c => c.classList.remove("selected"));
                card.classList.add("selected");
                select.value = opt.value;
                toggleSettings();
            });
            container.appendChild(card);
        });
        container.querySelector(".strategy-card").classList.add("selected");
    }

    window.toggleSettings = function() {
        const strategy = document.getElementById('strategy').value;
        const stratObj = strategies[strategy];
        const isSpot = stratObj && stratObj.type === "spot";
        document.getElementById("leverage-settings").style.display = isSpot ? "none" : (strategy === "rsi_leveraged" ? "grid" : "none");
        document.getElementById("smart-leverage-settings").style.display = strategy === "rsi_smart_leverage" ? "grid" : "none";
        document.getElementById("fundingRate").parentElement.style.display = isSpot ? "none" : "block";
        const container = document.getElementById("strategy-settings");
        container.innerHTML = "";
        if(strategy === "rsi_plus_spot"){
            container.innerHTML = `<div class="config-item"><label for="rsiPeriod">RSI Periyodu</label><input type="number" id="rsiPeriod" value="${defaultSettings.rsi_plus_spot.rsiPeriod}"></div><div class="config-item"><label for="rsiBuyLevel">RSI Alım Seviyesi</label><input type="number" id="rsiBuyLevel" value="${defaultSettings.rsi_plus_spot.rsiBuyLevel}"></div><div class="config-item"><label for="trendEmaPeriod">Trend EMA Periyodu</label><input type="number" id="trendEmaPeriod" value="${defaultSettings.rsi_plus_spot.emaPeriod}"></div>`;
        } else if(strategy === "rsi_reversal"){
            container.innerHTML = `<div class="config-item"><label for="rsiPeriod">RSI Periyodu</label><input type="number" id="rsiPeriod" value="${defaultSettings.rsi_reversal.rsiPeriod}"></div><div class="config-item"><label for="rsiBuyLevel">RSI Alım Seviyesi</label><input type="number" id="rsiBuyLevel" value="${defaultSettings.rsi_reversal.rsiBuyLevel}"></div>`;
        } else if(strategy === "ma_crossover"){
            container.innerHTML = `<div class="config-item"><label for="shortPeriod">Kısa MA</label><input type="number" id="shortPeriod" value="${defaultSettings.ma_crossover.shortPeriod}"></div><div class="config-item"><label for="longPeriod">Uzun MA</label><input type="number" id="longPeriod" value="${defaultSettings.ma_crossover.longPeriod}"></div>`;
        } else if(strategy === "bollinger_bands") {
            container.innerHTML = `<div class="config-item"><label for="bbPeriod">BB Periyodu</label><input type="number" id="bbPeriod" value="${defaultSettings.bollinger_bands.period}"></div><div class="config-item"><label for="bbStd">Std Sapma</label><input type="number" step="0.1" id="bbStd" value="${defaultSettings.bollinger_bands.stdDev}"></div>`;
        }
        if (defaultSettings[strategy]) {
            const d = defaultSettings[strategy];
            if (d.leverage !== undefined) document.getElementById('leverage').value = d.leverage;
            if (d.marginPercent !== undefined) document.getElementById('marginPercent').value = d.marginPercent;
            if (d.hourlyFundingRate !== undefined) document.getElementById('fundingRate').value = d.hourlyFundingRate;
            if (d.marginType !== undefined) document.getElementById('marginType').value = d.marginType;
            if (d.positionSize !== undefined) document.getElementById('positionSize').value = d.positionSize;
        }
    };
window.applyRiskProfile = function() {
        const profile = document.getElementById("riskProfile").value;
        const slInput = document.getElementById("stopLossPercent");
        const tpInput = document.getElementById("takeProfitPercent");
        if (profile === "manual") {
            tpInput.disabled = false;
        } else {
            let sl = parseFloat(slInput.value);
            if (!sl || sl <= 0) {
                sl = profile === "balanced" ? 1 : 1;
                slInput.value = sl.toFixed(2);
            }
            tpInput.value = profile === "balanced" ? (sl * 2).toFixed(2) : (sl * 3).toFixed(2);
            tpInput.disabled = true;
        }
    };


    function updateProgress(percentage, message) {
        const container = document.getElementById('progress-container');
        container.style.display = 'block';
        container.innerHTML = `<div id="progress-bar-bg" style="width:100%;background-color:#444;border-radius:4px;overflow:hidden;"><div id="progress-bar" style="width:${percentage}%;height:10px;background-color:var(--primary-color);transition:width .3s ease-in-out;border-radius:4px;"></div></div><pre id="progress-log" style="font-size:13px;color:var(--label-color);margin-top:10px;white-space:pre;">${message}</pre>`;
    }

    async function fetchKlines(symbol, interval, days) {
        const intervalMap = {'1m':1, '15m':15, '30m':30, '1h':60, '4h':240, '1d':1440};
        const candlesPerDay = 1440 / (intervalMap[interval] || 240);
        const candlesPerCall = 1000;
        const totalCandles = Math.ceil(days * candlesPerDay);
        const numCalls = Math.ceil(totalCandles / candlesPerCall);
        let allKlines = [];
        let endTime = Date.now();
        for (let i = 0; i < numCalls; i++) {
            const progress = 10 + (i / numCalls) * 40;
            updateProgress(progress, `Veri çekiliyor: ${symbol}... Paket ${i + 1} / ${numCalls}`);
            const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&endTime=${endTime}&limit=${candlesPerCall}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error(`API Hatası: ${response.status}`);
            const klines = await response.json();
            if (klines && klines.length > 0) {
                allKlines = klines.concat(allKlines);
                endTime = klines[0][0] - 1;
            } else { break; }
        }
        return allKlines.filter((v, i, a) => a.findIndex(t => (t[0] === v[0])) === i).sort((a,b) => a[0] - b[0]).slice(-totalCandles);
    }

    const calculateSMA = (data, period) => {
        if (data.length < period) return new Array(data.length).fill(null);
        let sma = new Array(data.length).fill(null);
        let sum = 0;
        for (let i = 0; i < data.length; i++) {
            sum += data[i];
            if (i >= period) {
                sum -= data[i - period];
                sma[i] = sum / period;
            } else if (i === period - 1) {
                sma[i] = sum / period;
            }
        }
        return sma;
    };

    const calculateEMA = (data, period) => {
        if (data.length < period) return new Array(data.length).fill(null);
        let ema = new Array(data.length).fill(null);
        const multiplier = 2 / (period + 1);
        let sum = 0;
        for (let i = 0; i < period; i++) sum += data[i];
        ema[period - 1] = sum / period;
        for (let i = period; i < data.length; i++) {
            ema[i] = ((data[i] - ema[i - 1]) * multiplier) + ema[i - 1];
        }
        return ema;
    };

    const calculateRSI = (prices, period = 14) => {
        let rsi = new Array(prices.length).fill(null);
        let gains = 0, losses = 0;
        for (let i = 1; i <= period; i++) {
            if(prices[i] === undefined || prices[i-1] === undefined) continue;
            const diff = prices[i] - prices[i - 1];
            if (diff >= 0) { gains += diff; } else { losses -= diff; }
        }
        let avgGain = gains / period;
        let avgLoss = losses / period;
        for (let i = period + 1; i < prices.length; i++) {
            const diff = prices[i] - prices[i - 1];
            if (diff >= 0) {
                avgGain = (avgGain * (period - 1) + diff) / period;
                avgLoss = (avgLoss * (period - 1)) / period;
            } else {
                avgLoss = (avgLoss * (period - 1) - diff) / period;
                avgGain = (avgGain * (period - 1)) / period;
            }
            if (avgLoss === 0) rsi[i] = 100; else {
                const rs = avgGain / avgLoss;
                rsi[i] = 100 - (100 / (1 + rs));
            }
        }
        return rsi;
    };
    function buildEquityCurve(trades, initial) {
        let balance = initial;
        const curve = [{ time: Date.now()/1000, value: initial }];
        trades.forEach(t => {
            if(t.pnl !== undefined) {
                balance += t.pnl;
                const time = t.time === "Test Sonu" ? Date.now()/1000 : Math.floor(new Date(t.time).getTime()/1000);
                curve.push({ time, value: balance });
            }
        });
        return curve;
    }

    const strategies = {
        rsi_plus_spot: {
            name: "RSI+ (Trend Filtreli)",
            type: 'spot',
            run: function(klines, initialBalance, commissionRate, compound = true, params = {}) {
                const prices = klines.map(k => parseFloat(k[4]));
                const rsiPeriod = params.rsiPeriod || 14;
                const buyLevel = params.rsiBuyLevel || 30;
                const emaPeriod = params.emaPeriod || 200;
                const stopLossPercent = params.stopLossPercent || 0;
                const takeProfitPercent = params.takeProfitPercent || 0;
                const rsi = calculateRSI(prices, rsiPeriod);
                const trendEma = calculateEMA(prices, emaPeriod);
                let balance = initialBalance,
                    cryptoAmount = 0,
                    entryPrice = 0,
                    trades = [],
                    totalFees = 0,
                    totalProfit = 0;
                for (let i = Math.max(rsiPeriod, emaPeriod); i < klines.length; i++) {
                    const high = parseFloat(klines[i][2]);
                    const low = parseFloat(klines[i][3]);
                    if (cryptoAmount > 0) {
                        const sl = entryPrice * (1 - stopLossPercent / 100);
                        const tp = entryPrice * (1 + takeProfitPercent / 100);
                        if (stopLossPercent > 0 && low <= sl) {
                            const sellValue = cryptoAmount * sl;
                            const fee = sellValue * (commissionRate / 100);
                            totalFees += fee;
                            const result = sellValue - fee;
                            if (compound) balance += result; else totalProfit += result - initialBalance;
                            trades.push({ type: 'STOP-LOSS', price: sl, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            cryptoAmount = 0;
                            if (!compound) balance = initialBalance;
                            continue;
                        }
                        if (takeProfitPercent > 0 && high >= tp) {
                            const sellValue = cryptoAmount * tp;
                            const fee = sellValue * (commissionRate / 100);
                            totalFees += fee;
                            const result = sellValue - fee;
                            if (compound) balance += result; else totalProfit += result - initialBalance;
                            trades.push({ type: 'TAKE-PROFIT', price: tp, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            cryptoAmount = 0;
                            if (!compound) balance = initialBalance;
                            continue;
                        }
                    }
                    if (prices[i] > trendEma[i] && rsi[i-1] > buyLevel && rsi[i] <= buyLevel && cryptoAmount === 0) {
                        const tradeBal = compound ? balance : initialBalance;
                        const fee = tradeBal * (commissionRate / 100);
                        totalFees += fee;
                        cryptoAmount = (tradeBal - fee) / prices[i];
                        entryPrice = prices[i];
                        if (compound) balance -= tradeBal;
                        trades.push({ type: 'BUY', price: prices[i], time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                    } else if (rsi[i-1] < 70 && rsi[i] >= 70 && cryptoAmount > 0) {
                        const sellValue = cryptoAmount * prices[i];
                        const fee = sellValue * (commissionRate / 100);
                        totalFees += fee;
                        const result = sellValue - fee;
                        if (compound) balance += result; else totalProfit += result - initialBalance;
                        trades.push({ type: 'SELL', price: prices[i], time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                        cryptoAmount = 0;
                        if (!compound) balance = initialBalance;
                    }
                }
                if (cryptoAmount > 0) {
                    const sellValue = cryptoAmount * prices[prices.length - 1];
                    const fee = sellValue * (commissionRate / 100);
                    totalFees += fee;
                    const result = sellValue - fee;
                    if (compound) balance += result; else totalProfit += result - initialBalance;
                }
                const finalBalance = compound ? balance : initialBalance + totalProfit;
                return { finalBalance, trades, totalFees, liquidationCount: 0 };
            }
        },
        rsi_reversal: {
            name: "RSI Geri Dönüşü (Spot)",
            type: 'spot',
            run: function(klines, initialBalance, commissionRate, compound = true, params = {}) {
                const prices = klines.map(k => parseFloat(k[4]));
                const rsiPeriod = params.rsiPeriod || 14;
                const buyLevel = params.rsiBuyLevel || 30;
                const stopLossPercent = params.stopLossPercent || 0;
                const takeProfitPercent = params.takeProfitPercent || 0;
                const rsi = calculateRSI(prices, rsiPeriod);
                let balance = initialBalance,
                    cryptoAmount = 0,
                    entryPrice = 0,
                    trades = [],
                    totalFees = 0,
                    totalProfit = 0;
                for (let i = rsiPeriod; i < klines.length; i++) {
                    const high = parseFloat(klines[i][2]);
                    const low = parseFloat(klines[i][3]);
                    if (cryptoAmount > 0) {
                        const sl = entryPrice * (1 - stopLossPercent / 100);
                        const tp = entryPrice * (1 + takeProfitPercent / 100);
                        if (stopLossPercent > 0 && low <= sl) {
                            const sellValue = cryptoAmount * sl;
                            const fee = sellValue * (commissionRate / 100);
                            totalFees += fee;
                            const result = sellValue - fee;
                            if (compound) balance += result; else totalProfit += result - initialBalance;
                            trades.push({ type: 'STOP-LOSS', price: sl, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            cryptoAmount = 0;
                            if (!compound) balance = initialBalance;
                            continue;
                        }
                        if (takeProfitPercent > 0 && high >= tp) {
                            const sellValue = cryptoAmount * tp;
                            const fee = sellValue * (commissionRate / 100);
                            totalFees += fee;
                            const result = sellValue - fee;
                            if (compound) balance += result; else totalProfit += result - initialBalance;
                            trades.push({ type: 'TAKE-PROFIT', price: tp, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            cryptoAmount = 0;
                            if (!compound) balance = initialBalance;
                            continue;
                        }
                    }
                    if (rsi[i-1] > buyLevel && rsi[i] <= buyLevel && cryptoAmount === 0) {
                        const tradeBal = compound ? balance : initialBalance;
                        const fee = tradeBal * (commissionRate / 100);
                        totalFees += fee;
                        cryptoAmount = (tradeBal - fee) / prices[i];
                        entryPrice = prices[i];
                        if (compound) balance -= tradeBal;
                        trades.push({ type: 'BUY', price: prices[i], time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                    } else if (rsi[i-1] < 70 && rsi[i] >= 70 && cryptoAmount > 0) {
                        const sellValue = cryptoAmount * prices[i];
                        const fee = sellValue * (commissionRate / 100);
                        totalFees += fee;
                        const result = sellValue - fee;
                        if (compound) balance += result; else totalProfit += result - initialBalance;
                        trades.push({ type: 'SELL', price: prices[i], time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                        cryptoAmount = 0;
                        if (!compound) balance = initialBalance;
                    }
                }
                if (cryptoAmount > 0) {
                    const sellValue = cryptoAmount * prices[prices.length - 1];
                    const fee = sellValue * (commissionRate / 100);
                    totalFees += fee;
                    const result = sellValue - fee;
                    if (compound) balance += result; else totalProfit += result - initialBalance;
                }
                const finalBalance = compound ? balance : initialBalance + totalProfit;
                return { finalBalance, trades, totalFees, liquidationCount: 0 };
            }
        },
        ma_crossover: {
            name: "MA Kesişimi (Spot Trend)",
            type: 'spot',
            run: function(klines, initialBalance, commissionRate, compound = true, params = {}) {
                const prices = klines.map(k => parseFloat(k[4]));
                const shortPeriod = params.shortPeriod || 20;
                const longPeriod = params.longPeriod || 50;
                const stopLossPercent = params.stopLossPercent || 0;
                const takeProfitPercent = params.takeProfitPercent || 0;
                const smaShort = calculateSMA(prices, shortPeriod);
                const smaLong = calculateSMA(prices, longPeriod);
                let balance = initialBalance,
                    cryptoAmount = 0,
                    entryPrice = 0,
                    trades = [],
                    totalFees = 0,
                    totalProfit = 0;
                for (let i = longPeriod; i < klines.length; i++) {
                    const high = parseFloat(klines[i][2]);
                    const low = parseFloat(klines[i][3]);
                    if (cryptoAmount > 0) {
                        const sl = entryPrice * (1 - stopLossPercent / 100);
                        const tp = entryPrice * (1 + takeProfitPercent / 100);
                        if (stopLossPercent > 0 && low <= sl) {
                            const sellValue = cryptoAmount * sl;
                            const fee = sellValue * (commissionRate / 100);
                            totalFees += fee;
                            const result = sellValue - fee;
                            if (compound) balance += result; else totalProfit += result - initialBalance;
                            trades.push({ type: 'STOP-LOSS', price: sl, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            cryptoAmount = 0;
                            if (!compound) balance = initialBalance;
                            continue;
                        }
                        if (takeProfitPercent > 0 && high >= tp) {
                            const sellValue = cryptoAmount * tp;
                            const fee = sellValue * (commissionRate / 100);
                            totalFees += fee;
                            const result = sellValue - fee;
                            if (compound) balance += result; else totalProfit += result - initialBalance;
                            trades.push({ type: 'TAKE-PROFIT', price: tp, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            cryptoAmount = 0;
                            if (!compound) balance = initialBalance;
                            continue;
                        }
                    }
                    if (smaShort[i-1] < smaLong[i-1] && smaShort[i] > smaLong[i] && cryptoAmount === 0) {
                        const tradeBal = compound ? balance : initialBalance;
                        const fee = tradeBal * (commissionRate / 100);
                        totalFees += fee;
                        cryptoAmount = (tradeBal - fee) / prices[i];
                        entryPrice = prices[i];
                        if (compound) balance -= tradeBal;
                        trades.push({ type: 'BUY', price: prices[i], time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                    } else if (smaShort[i-1] > smaLong[i-1] && smaShort[i] < smaLong[i] && cryptoAmount > 0) {
                        const sellValue = cryptoAmount * prices[i];
                        const fee = sellValue * (commissionRate / 100);
                        totalFees += fee;
                        const result = sellValue - fee;
                        if (compound) balance += result; else totalProfit += result - initialBalance;
                        trades.push({ type: 'SELL', price: prices[i], time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                        cryptoAmount = 0;
                        if (!compound) balance = initialBalance;
                    }
                }
                if (cryptoAmount > 0) {
                    const sellValue = cryptoAmount * prices[prices.length - 1];
                    const fee = sellValue * (commissionRate / 100);
                    totalFees += fee;
                    const result = sellValue - fee;
                    if (compound) balance += result; else totalProfit += result - initialBalance;
                }
                const finalBalance = compound ? balance : initialBalance + totalProfit;
                return { finalBalance, trades, totalFees, liquidationCount: 0 };
            }
        },
        bollinger_bands: {
            name: "Bollinger Bandı (Volatilite)",
            type: 'spot',
            run: function(klines, initialBalance, commissionRate, compound = true, params = {}) {
                const prices = klines.map(k => parseFloat(k[4]));
                const period = params.bbPeriod || 20;
                const stdDev = params.bbStd || 2;
                const sma = calculateSMA(prices, period);
                const upper = new Array(prices.length).fill(null);
                const lower = new Array(prices.length).fill(null);
                for (let i = period - 1; i < prices.length; i++) {
                    let variance = 0;
                    for (let j = i - period + 1; j <= i; j++) variance += Math.pow(prices[j] - sma[i], 2);
                    const sd = Math.sqrt(variance / period);
                    upper[i] = sma[i] + stdDev * sd;
                    lower[i] = sma[i] - stdDev * sd;
                }
                const stopLossPercent = params.stopLossPercent || 0;
                const takeProfitPercent = params.takeProfitPercent || 0;
                let balance = initialBalance,
                    cryptoAmount = 0,
                    entryPrice = 0,
                    trades = [],
                    totalFees = 0,
                    totalProfit = 0;
                for (let i = period; i < klines.length; i++) {
                    const high = parseFloat(klines[i][2]);
                    const low = parseFloat(klines[i][3]);
                    if (cryptoAmount > 0) {
                        const sl = entryPrice * (1 - stopLossPercent / 100);
                        const tp = entryPrice * (1 + takeProfitPercent / 100);
                        if (stopLossPercent > 0 && low <= sl) {
                            const sellValue = cryptoAmount * sl;
                            const fee = sellValue * (commissionRate / 100);
                            totalFees += fee;
                            const result = sellValue - fee;
                            if (compound) balance += result; else totalProfit += result - initialBalance;
                            trades.push({ type: 'STOP-LOSS', price: sl, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            cryptoAmount = 0;
                            if (!compound) balance = initialBalance;
                            continue;
                        }
                        if (takeProfitPercent > 0 && high >= tp) {
                            const sellValue = cryptoAmount * tp;
                            const fee = sellValue * (commissionRate / 100);
                            totalFees += fee;
                            const result = sellValue - fee;
                            if (compound) balance += result; else totalProfit += result - initialBalance;
                            trades.push({ type: 'TAKE-PROFIT', price: tp, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            cryptoAmount = 0;
                            if (!compound) balance = initialBalance;
                            continue;
                        }
                    }
                    if (prices[i-1] < lower[i-1] && prices[i] > lower[i] && cryptoAmount === 0) {
                        const tradeBal = compound ? balance : initialBalance;
                        const fee = tradeBal * (commissionRate / 100);
                        totalFees += fee;
                        cryptoAmount = (tradeBal - fee) / prices[i];
                        entryPrice = prices[i];
                        if (compound) balance -= tradeBal;
                        trades.push({ type: 'BUY', price: prices[i], time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                    } else if (prices[i-1] > upper[i-1] && prices[i] < upper[i] && cryptoAmount > 0) {
                        const sellValue = cryptoAmount * prices[i];
                        const fee = sellValue * (commissionRate / 100);
                        totalFees += fee;
                        const result = sellValue - fee;
                        if (compound) balance += result; else totalProfit += result - initialBalance;
                        trades.push({ type: 'SELL', price: prices[i], time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                        cryptoAmount = 0;
                        if (!compound) balance = initialBalance;
                    }
                }
                if (cryptoAmount > 0) {
                    const sellValue = cryptoAmount * prices[prices.length - 1];
                    const fee = sellValue * (commissionRate / 100);
                    totalFees += fee;
                    const result = sellValue - fee;
                    if (compound) balance += result; else totalProfit += result - initialBalance;
                }
                const finalBalance = compound ? balance : initialBalance + totalProfit;
                return { finalBalance, trades, totalFees, liquidationCount: 0 };
            }
        },
        rsi_smart_leverage: {
            name: "Akıllı Kaldıraç RSI",
            type: 'leveraged',
            run: function(klines, initialBalance, settings) {
                const { positionSize, commissionRate, hourlyFundingRate, marginType, compound, stopLossPercent, takeProfitPercent, direction } = settings;
                const prices = klines.map(k => parseFloat(k[4]));
                const rsi = calculateRSI(prices, 14);
                const intervalMap = { '1m': 1/60, '15m': 0.25, '30m': 0.5, '1h':1, '4h':4, '1d':24 };
                const intervalHours = intervalMap[document.getElementById('interval').value] || 4;
                let balance = initialBalance,
                    inPosition = false,
                    positionSizeUsd = positionSize,
                    marginUsed = 0,
                    entryPrice = 0,
                    side = 'long',
                    trades = [],
                    totalFees = 0,
                    liquidationCount = 0,
                    leverage = 1;
                for (let i = 14; i < klines.length; i++) {
                    const currentPrice = prices[i];
                    const candleHigh = parseFloat(klines[i][2]);
                    const candleLow = parseFloat(klines[i][3]);
                    if (inPosition) {
                        const fundingFee = positionSizeUsd * (hourlyFundingRate / 100) * intervalHours;
                        balance -= fundingFee;
                        totalFees += fundingFee;
                        const sl = side === 'long' ? entryPrice * (1 - stopLossPercent/100) : entryPrice * (1 + stopLossPercent/100);
                        const tp = side === 'long' ? entryPrice * (1 + takeProfitPercent/100) : entryPrice * (1 - takeProfitPercent/100);
                        const liqPrice = side === 'long' ? entryPrice * (1 - 1/leverage) : entryPrice * (1 + 1/leverage);
                        if ((side==='long' && candleLow <= liqPrice) || (side==='short' && candleHigh >= liqPrice)) {
                            let pnl = -marginUsed;
                            if (marginType === 'cross') { pnl = -balance; balance = 0; } else { balance += pnl; }
                            liquidationCount++;
                            trades.push({ type:'LIQUIDATION', price: liqPrice, pnl, time:new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = false;
                            if (marginType === 'cross') break;
                            continue;
                        }
                        if (stopLossPercent>0 && ((side==='long' && candleLow<=sl) || (side==='short' && candleHigh>=sl))) {
                            const exitPrice = sl;
                            const exitValue = (positionSizeUsd / entryPrice) * exitPrice;
                            const fee = exitValue * (commissionRate / 100);
                            balance -= fee;
                            totalFees += fee;
                            const pnl = side==='long'? exitValue - positionSizeUsd : positionSizeUsd - exitValue;
                            balance += pnl;
                            trades.push({ type:'STOP-LOSS', price: exitPrice, pnl, pnl_percent:(pnl/marginUsed)*100, time:new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = false;
                            continue;
                        }
                        if (takeProfitPercent>0 && ((side==='long' && candleHigh>=tp) || (side==='short' && candleLow<=tp))) {
                            const exitPrice = tp;
                            const exitValue = (positionSizeUsd / entryPrice) * exitPrice;
                            const fee = exitValue * (commissionRate / 100);
                            balance -= fee;
                            totalFees += fee;
                            const pnl = side==='long'? exitValue - positionSizeUsd : positionSizeUsd - exitValue;
                            balance += pnl;
                            trades.push({ type:'TAKE-PROFIT', price: exitPrice, pnl, pnl_percent:(pnl/marginUsed)*100, time:new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = false;
                            continue;
                        }
                        if (side==='long' && rsi[i-1] < 70 && rsi[i] >= 70) {
                            const exitValue = (positionSizeUsd / entryPrice) * currentPrice;
                            const fee = exitValue * (commissionRate / 100);
                            balance -= fee; totalFees += fee;
                            const pnl = exitValue - positionSizeUsd;
                            balance += pnl;
                            trades.push({ type:'CLOSE', price: currentPrice, pnl, pnl_percent:(pnl/marginUsed)*100, time:new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = false;
                            continue;
                        }
                        if (side==='short' && rsi[i-1] > 30 && rsi[i] <= 30) {
                            const exitValue = (positionSizeUsd / entryPrice) * currentPrice;
                            const fee = exitValue * (commissionRate / 100);
                            balance -= fee; totalFees += fee;
                            const pnl = positionSizeUsd - exitValue;
                            balance += pnl;
                            trades.push({ type:'CLOSE', price: currentPrice, pnl, pnl_percent:(pnl/marginUsed)*100, time:new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = false;
                            continue;
                        }
                    }
                    if (!inPosition) {
                        const baseBal = compound ? balance : initialBalance;
                        marginUsed = baseBal;
                        if (baseBal <= 0) continue;
                        leverage = positionSizeUsd / marginUsed;
                        if (leverage < 1) continue;
                        const fee = positionSizeUsd * (commissionRate / 100);
                        balance -= fee;
                        totalFees += fee;
                        entryPrice = currentPrice;
                        side = null;
                        if ((direction !== 'short') && rsi[i-1] > 30 && rsi[i] <= 30) {
                            side = 'long';
                        } else if ((direction !== 'long') && rsi[i-1] < 70 && rsi[i] >= 70) {
                            side = 'short';
                        }
                        if (side) {
                            trades.push({ type: side==='long' ? 'LONG' : 'SHORT', price: entryPrice, size: positionSizeUsd, leverage: leverage.toFixed(2), time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = true;
                        } else {
                            balance += fee;
                            totalFees -= fee;
                        }
                    }
                }
                if (inPosition) {
                    const exitPrice = prices[prices.length - 1];
                    const exitValue = (positionSizeUsd / entryPrice) * exitPrice;
                    const fee = exitValue * (commissionRate / 100);
                    balance -= fee; totalFees += fee;
                    const pnl = side==='long'? exitValue - positionSizeUsd : positionSizeUsd - exitValue;
                    balance += pnl;
                    trades.push({ type:'CLOSE', price: exitPrice, pnl, pnl_percent:(pnl/marginUsed)*100, time:'Test Sonu' });
                }
                return { finalBalance: balance, trades, totalFees, liquidationCount };
            }
        },
        rsi_leveraged: {
            name: "RSI Kaldıraçlı (Standart)",
            type: 'leveraged',
            run: function(klines, initialBalance, settings) {
                const { leverage, marginPercent, commissionRate, hourlyFundingRate, marginType, compound, stopLossPercent, takeProfitPercent, direction } = settings;
                const prices = klines.map(k => parseFloat(k[4]));
                const rsi = calculateRSI(prices, 14);
                const intervalMap = { '1m': 1/60, '15m': 0.25, '30m': 0.5, '1h':1, '4h':4, '1d':24 };
                const intervalHours = intervalMap[document.getElementById('interval').value] || 4;
                let balance = initialBalance,
                    inPosition = false,
                    positionSizeUsd = 0,
                    marginUsed = 0,
                    entryPrice = 0,
                    side = 'long',
                    trades = [],
                    totalFees = 0,
                    liquidationCount = 0;
                for (let i = 14; i < klines.length; i++) {
                    const currentPrice = prices[i];
                    const candleHigh = parseFloat(klines[i][2]);
                    const candleLow = parseFloat(klines[i][3]);
                    if (inPosition) {
                        const fundingFee = positionSizeUsd * (hourlyFundingRate / 100) * intervalHours;
                        balance -= fundingFee;
                        totalFees += fundingFee;
                        const sl = side === 'long' ? entryPrice * (1 - stopLossPercent/100) : entryPrice * (1 + stopLossPercent/100);
                        const tp = side === 'long' ? entryPrice * (1 + takeProfitPercent/100) : entryPrice * (1 - takeProfitPercent/100);
                        if (stopLossPercent>0 && ((side==='long' && candleLow<=sl) || (side==='short' && candleHigh>=sl))) {
                            const exitPrice = sl;
                            const exitValue = (positionSizeUsd / entryPrice) * exitPrice;
                            const fee = exitValue * (commissionRate / 100);
                            balance -= fee;
                            totalFees += fee;
                            const pnl = side==='long'? exitValue - positionSizeUsd : positionSizeUsd - exitValue;
                            balance += pnl;
                            trades.push({ type: 'STOP-LOSS', price: exitPrice, pnl, pnl_percent: (pnl / marginUsed) * 100, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = false;
                            continue;
                        }
                        if (takeProfitPercent>0 && ((side==='long' && candleHigh>=tp) || (side==='short' && candleLow<=tp))) {
                            const exitPrice = tp;
                            const exitValue = (positionSizeUsd / entryPrice) * exitPrice;
                            const fee = exitValue * (commissionRate / 100);
                            balance -= fee;
                            totalFees += fee;
                            const pnl = side==='long'? exitValue - positionSizeUsd : positionSizeUsd - exitValue;
                            balance += pnl;
                            trades.push({ type: 'TAKE-PROFIT', price: exitPrice, pnl, pnl_percent: (pnl / marginUsed) * 100, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = false;
                            continue;
                        }
                        if (side==='long' && rsi[i-1] < 70 && rsi[i] >= 70) {
                            const exitValue = (positionSizeUsd / entryPrice) * currentPrice;
                            const fee = exitValue * (commissionRate / 100);
                            balance -= fee; totalFees += fee;
                            const pnl = exitValue - positionSizeUsd;
                            balance += pnl;
                            trades.push({ type: 'CLOSE', price: currentPrice, pnl, pnl_percent: (pnl / marginUsed) * 100, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = false;
                            continue;
                        }
                        if (side==='short' && rsi[i-1] > 30 && rsi[i] <= 30) {
                            const exitValue = (positionSizeUsd / entryPrice) * currentPrice;
                            const fee = exitValue * (commissionRate / 100);
                            balance -= fee; totalFees += fee;
                            const pnl = positionSizeUsd - exitValue;
                            balance += pnl;
                            trades.push({ type: 'CLOSE', price: currentPrice, pnl, pnl_percent: (pnl / marginUsed) * 100, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = false;
                            continue;
                        }
                    }
                    if (!inPosition) {
                        const baseBal = compound ? balance : initialBalance;
                        marginUsed = baseBal * (marginPercent / 100);
                        if (baseBal <= 0 || baseBal < marginUsed) continue;
                        positionSizeUsd = marginUsed * leverage;
                        const fee = positionSizeUsd * (commissionRate / 100);
                        balance -= fee;
                        totalFees += fee;
                        entryPrice = currentPrice;
                        side = null;
                        if ((direction !== 'short') && rsi[i-1] > 30 && rsi[i] <= 30) {
                            side = 'long';
                        } else if ((direction !== 'long') && rsi[i-1] < 70 && rsi[i] >= 70) {
                            side = 'short';
                        }
                        if (side) {
                            trades.push({ type: side === 'long' ? 'LONG' : 'SHORT', price: entryPrice, size: positionSizeUsd, leverage, time: new Date(klines[i][0]).toLocaleString('tr-TR') });
                            inPosition = true;
                        } else {
                            balance += fee;
                            totalFees -= fee;
                        }
                    }
                }
                if (inPosition) {
                    const exitPrice = prices[prices.length - 1];
                    const exitValue = (positionSizeUsd / entryPrice) * exitPrice;
                    const fee = exitValue * (commissionRate / 100);
                    balance -= fee; totalFees += fee;
                    const pnl = side==='long'? exitValue - positionSizeUsd : positionSizeUsd - exitValue;
                    balance += pnl;
                    trades.push({ type: 'CLOSE', price: exitPrice, pnl, pnl_percent: (pnl / marginUsed) * 100, time: 'Test Sonu' });
                }
                return { finalBalance: balance, trades, totalFees, liquidationCount };
            }
        }
    };
    window.runBacktest = async function() {
        document.getElementById('runBtn').disabled = true;
        document.getElementById('downloadBtn').style.display = 'none';
        const resultsDiv = document.getElementById('results');
        resultsDiv.style.display = 'none';
        resultsDiv.innerHTML = '';
        allResults = [];
        try {
            const selectedPeriods = Array.from(document.querySelectorAll('.period-chip.selected')).map(c => parseInt(c.dataset.days));
            if (selectedPeriods.length === 0) { throw new Error("Lütfen en az bir test periyodu seçin."); }
            for (const daysToTest of selectedPeriods) {
                const strategyKey = document.getElementById('strategy').value;
                const selectedStrategy = strategies[strategyKey];
                if(!selectedStrategy) throw new Error(`Bilinmeyen strateji: ${strategyKey}`);
                const pair = document.getElementById('pair').value;
                const initialBalance = parseFloat(document.getElementById('initialBalance').value);
                const interval = document.getElementById('interval').value;
                const commissionRate = parseFloat(document.getElementById('commission').value);
                const klines = await fetchKlines(pair, interval, daysToTest);
                updateProgress(50, `Strateji yürütülüyor: ${daysToTest} günlük periyot...`);
                let result;
                const compound = document.getElementById('compoundProfits').checked;
                const sl = parseFloat(document.getElementById('stopLossPercent').value);
                const tp = parseFloat(document.getElementById('takeProfitPercent').value);
                const direction = document.getElementById('direction').value;
                if (selectedStrategy.type.includes('leveraged')) {
                    const settings = {
                        leverage: parseFloat(document.getElementById('leverage').value),
                        marginPercent: parseFloat(document.getElementById('marginPercent').value),
                        hourlyFundingRate: parseFloat(document.getElementById('fundingRate').value),
                        marginType: document.getElementById('marginType').value,
                        commissionRate,
                        positionSize: document.getElementById('positionSize') ? parseFloat(document.getElementById('positionSize').value) : undefined,
                        compound,
                        stopLossPercent: sl,
                        takeProfitPercent: tp,
                        direction
                    };
                    result = selectedStrategy.run(klines, initialBalance, settings);
                } else {
                    const params = {
                        stopLossPercent: sl,
                        takeProfitPercent: tp,
                        rsiPeriod: document.getElementById('rsiPeriod') ? parseInt(document.getElementById('rsiPeriod').value) : undefined,
                        rsiBuyLevel: document.getElementById('rsiBuyLevel') ? parseFloat(document.getElementById('rsiBuyLevel').value) : undefined,
                        emaPeriod: document.getElementById('trendEmaPeriod') ? parseInt(document.getElementById('trendEmaPeriod').value) : undefined,
                        shortPeriod: document.getElementById('shortPeriod') ? parseInt(document.getElementById('shortPeriod').value) : undefined,
                        longPeriod: document.getElementById('longPeriod') ? parseInt(document.getElementById('longPeriod').value) : undefined,
                        bbPeriod: document.getElementById('bbPeriod') ? parseInt(document.getElementById('bbPeriod').value) : undefined,
                        bbStd: document.getElementById('bbStd') ? parseFloat(document.getElementById('bbStd').value) : undefined
                    };
                    result = selectedStrategy.run(klines, initialBalance, commissionRate, compound, params);
                }
                  const equity = buildEquityCurve(result.trades, initialBalance);
                const params = {
                    strategy: strategyKey,
                    pair,
                    interval,
                    days: daysToTest,
                    commission: commissionRate,
                    leverage: selectedStrategy.type.includes('leveraged') ? document.getElementById('leverage').value : null,
                    marginPercent: selectedStrategy.type.includes('leveraged') ? document.getElementById('marginPercent').value : null,
                    fundingRate: selectedStrategy.type.includes('leveraged') ? document.getElementById('fundingRate').value : null,
                    marginType: selectedStrategy.type.includes('leveraged') ? document.getElementById('marginType').value : null,
                    positionSize: selectedStrategy.name.includes('Akıllı') ? document.getElementById('positionSize').value : null,
                    stopLossPercent: sl,
                    takeProfitPercent: tp,
                    bbPeriod: document.getElementById('bbPeriod') ? document.getElementById('bbPeriod').value : null,
                    bbStd: document.getElementById('bbStd') ? document.getElementById('bbStd').value : null,
                    direction: direction,
                    strategy: strategyKey
                };
                allResults.push({ ...result, initialBalance, params, klines, equity });
            }
            updateProgress(100, "Rapor oluşturuluyor...");
            generateAndDisplayReport();
        } catch (error) {
            updateProgress(100, `Hata: ${error.message}`);
            const progressBar = document.getElementById('progress-bar');
            if(progressBar) progressBar.style.backgroundColor = 'var(--loss-color)';
        } finally {
            document.getElementById('runBtn').disabled = false;
        }
    };
    
    function generateAndDisplayReport() {
        const resultsDiv = document.getElementById('results');
        allResultsHtml = "";
        allResults.forEach(result => {
            const { finalBalance, initialBalance, trades, totalFees, liquidationCount, params } = result;
            const grossPnl = finalBalance - initialBalance + totalFees;
            const netPnl = finalBalance - initialBalance;
            const pnlClass = netPnl >= 0 ? 'profit' : 'loss'; const pnlSign = netPnl >= 0 ? '+' : '';
            const strategyName = strategies[params.strategy].name;
            let periodText = "";
            if (params.days >= 365) periodText = `${Math.round(params.days/365)} Yıl`; else if (params.days >= 30) periodText = `${Math.round(params.days/30)} Ay`; else if (params.days >= 7) periodText = `${params.days} Gün`; else periodText = `${params.days} Gün`;
            let winCount = 0, totalProfit = 0, totalLoss = 0, tradeCount = 0;
            if(params.leverage || params.positionSize) {
                trades.forEach(trade => { if(trade.type === 'CLOSE' || trade.type === 'LIQUIDATION' || trade.type === 'STOP-LOSS' || trade.type === 'TAKE-PROFIT') { tradeCount++; if(trade.pnl > 0) { winCount++; totalProfit += trade.pnl; } else { totalLoss += Math.abs(trade.pnl); } } });
            } else {
                tradeCount = Math.floor(trades.length / 2); let lastBuyPrice = 0;
                for (let i = 0; i < trades.length; i+=2) { if (trades[i] && trades[i+1]) { const pnl = (trades[i+1].price - trades[i].price); if (pnl > 0) { winCount++; totalProfit += pnl; } else { totalLoss += Math.abs(pnl); } } }
            }
            const winRate = tradeCount > 0 ? (winCount / tradeCount * 100).toFixed(2) : 0;
            const profitFactor = totalLoss > 0 ? (totalProfit / totalLoss).toFixed(2) : (totalProfit > 0 ? '∞' : '0');
            
            let htmlReport = `<div class="report-section"><h3>Test Sonuçları: ${strategyName} - ${periodText}</h3><dl class="report-dl">`;
            htmlReport += `<dt>Parite</dt><dd>${params.pair} (${params.interval})</dd>`;
            if (params.leverage) { htmlReport += `<dt>Kaldıraç</dt><dd>${params.leverage}x (${params.marginType}) - %${params.marginPercent} Margin</dd>`;}
            if (params.positionSize) { htmlReport += `<dt>İşlem Büyüklüğü</dt><dd>${params.positionSize} USD (Otomatik Kaldıraç)</dd>`;}
            htmlReport += `<dt>Başlangıç Bak.</dt><dd>${initialBalance.toFixed(2)} USD</dd><dt>Son Bakiye</dt><dd>${finalBalance.toFixed(2)} USD</dd>`;
            htmlReport += `<dt>Brüt Kâr/Zarar</dt><dd>${grossPnl.toFixed(2)} USD</dd><dt>Toplam Maliyet</dt><dd><span class="loss">${totalFees.toFixed(2)} USD</span></dd>`;
            htmlReport += `<dt><strong>Net Kâr/Zarar</strong></dt><dd><strong class="${pnlClass}">${pnlSign}${netPnl.toFixed(2)} USD</strong></dd>`;
            htmlReport += `<dt>Kazanma Oranı</dt><dd>${winRate}%</dd><dt>Kâr Faktörü</dt><dd>${profitFactor}</dd>`;
            if (params.leverage || params.positionSize) { htmlReport += `<dt>Likidasyon</dt><dd><span class="loss">${liquidationCount} kez</span></dd>`;}
            htmlReport += `</dl><h4>İşlem Kayıtları</h4><div class="log-container">`;
            trades.forEach((trade, i) => {
                if (trade.type === 'LONG') { htmlReport += `<p>[${Math.floor(i/2)+1}] <span class="profit">LONG</span> @ ${trade.price.toFixed(4)} | Poz. Büyüklüğü: ${trade.size.toFixed(2)}$ ${trade.leverage ? `(${trade.leverage}x)` : ''} (${trade.time})</p>`; } 
                else if (trade.type === 'CLOSE') { const pnlCls = trade.pnl >= 0 ? 'profit' : 'loss'; htmlReport += `<p>&nbsp;&nbsp;<span class="${pnlCls}">CLOSE</span> @ ${trade.price.toFixed(4)} | K/Z: ${trade.pnl.toFixed(2)}$ (%${trade.pnl_percent.toFixed(2)}) (${trade.time})</p>`; } 
                else if (trade.type === 'STOP-LOSS' || trade.type === 'TAKE-PROFIT') { const cls = trade.type === 'STOP-LOSS' ? "loss" : "profit"; htmlReport += `<p>&nbsp;&nbsp;<span class="${cls}">${trade.type}</span> @ ${trade.price.toFixed(4)} | K/Z: ${trade.pnl.toFixed(2)}$ (%${trade.pnl_percent.toFixed(2)}) (${trade.time})</p>`; }
                else if (trade.type === 'LIQUIDATION') { htmlReport += `<p>&nbsp;&nbsp;<span class="loss">LİKİDASYON</span> @ ${trade.price.toFixed(4)} | Kayıp: ${Math.abs(trade.pnl).toFixed(2)}$ (${trade.time})</p>`; } 
                else { const typeClass = trade.type === 'BUY' ? 'profit' : 'loss'; htmlReport += `<p>[${Math.floor(i/2)+1}] <span class="${typeClass}">${trade.type}</span> @ ${trade.price.toFixed(4)} USD (${trade.time})</p>`; }
            });
            htmlReport += `</div></div>`;
            allResultsHtml += htmlReport;
        });
        
        if(allResults.length>0){ renderCharts(allResults[0].equity, allResults[0].klines, allResults[0].trades); }
        resultsDiv.innerHTML = allResultsHtml;
        resultsDiv.style.display = 'block';
        document.getElementById('progress-container').style.display = 'none';
        if(allResults.length > 0 && allResults.some(r => r.trades.length > 0)) document.getElementById('downloadBtn').style.display = 'flex';
    };
    function renderCharts(equity, klines, trades){
        const eqDiv=document.getElementById("equityChart");
        const prDiv=document.getElementById("priceChart");
        eqDiv.innerHTML=""; prDiv.innerHTML="";
        const ec=LightweightCharts.createChart(eqDiv,{height:300,layout:{background:{color:"#1b1d1f"},textColor:"#e0e0e0"},grid:{vertLines:{color:"#333"},horzLines:{color:"#333"}}});
        ec.addLineSeries({color:"#ffcc33"}).setData(equity);
        const pc=LightweightCharts.createChart(prDiv,{height:300,layout:{background:{color:"#1b1d1f"},textColor:"#e0e0e0"},grid:{vertLines:{color:"#333"},horzLines:{color:"#333"}}});
        const candleSeries=pc.addCandlestickSeries();
        candleSeries.setData(klines.map(k=>({time:Math.floor(k[0]/1000),open:+k[1],high:+k[2],low:+k[3],close:+k[4]})));
        candleSeries.setMarkers(trades.map(t=>({time:Math.floor(new Date(t.time==="Test Sonu"?Date.now():t.time).getTime()/1000),position:(t.type==="BUY"||t.type==="LONG")?"below":"above",color:(t.type==="BUY"||t.type==="LONG")?"#0f0":"#f00",shape:(t.type==="BUY"||t.type==="LONG")?"arrowUp":"arrowDown",text:t.type})));
    }

    
    window.generateAndDownloadHtmlReport = function() {
        if (!allResultsHtml) return;
        const finalHtml = `<!DOCTYPE html><html lang="tr"><head><meta charset="UTF-8"><title>Backtest Raporu</title><style>:root{--bg-color:#101214;--surface-color:#1b1d1f;--primary-color:#ffcc33;--text-color:#e0e0e0;--border-color:#333;--profit-color:#00ff9d;--loss-color:#ff4d6a;}body{font-family:'Funnel Sans',sans-serif;background-color:var(--bg-color);color:var(--text-color);padding:25px;line-height:1.7;} .container{max-width:800px;margin:auto;} h1{color:var(--primary-color);font-size:2em;margin-bottom:30px;} .report-section{margin-bottom:40px;} .report-section h3{font-size:1.5em;color:var(--primary-color);border-bottom:1px solid var(--border-color);padding-bottom:10px;margin-bottom:20px;} .report-dl{display:grid;grid-template-columns:max-content auto;gap:12px 25px;} .report-dl dt{font-weight:700;color:#aaa;} .report-dl dd{font-weight:700;font-size:1.1em;} .report-dl strong{font-size:1.4em;} .log-container{background-color:#0a0a0a;padding:15px;border-radius:8px;font-size:12px;margin-top:20px;max-height:400px;overflow-y:auto;} .log-container p{margin:5px 0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;} .profit{color:var(--profit-color);}.loss{color:var(--loss-color);}</style></head><body><div class="container"><h1>Backtest Sonuç Raporu</h1>${allResultsHtml}</div></body></html>`;
        const blob = new Blob([finalHtml], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `pro_backtest_raporu.html`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
    };

    window.onload = function(){
        const lang = localStorage.getItem('lang') || 'tr';
        setLanguage(lang);
        initPeriodChips();
        initStrategyCards();
        applyRiskProfile();
        document.getElementById("stopLossPercent").addEventListener("input", applyRiskProfile);
        toggleSettings();
    };
}());
</script>
</body>
</html>
